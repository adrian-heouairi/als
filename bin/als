#!/bin/bash

source -- "$(dirname -- "$(dirname -- "$(realpath -- "$0")")")/source/als-bin.sh" || exit 1

# Bypass set -u
action=${1+"$1"}
shift

mkdir -p -- ~/bin ~/.local/bin ~/.local/share/applications ~/.config/autostart "$ALS_INSTALLED_FULLPATH" "$ALS_CUSTOM_FULLPATH" "$ALS_INSTALLED_FULLPATH"/{packages,programs,bin-symlinks} "$ALS_CUSTOM_FULLPATH"/{bin,autostart.d,env.d,repository}

cp -f -- "$ALS_FULLPATH"/als-autostart.desktop ~/.config/autostart/
put-line-in-file.sh ~/.bashrc "source -- $ALS_FULLPATH_SHELL/source/env.sh"
put-line-in-file.sh ~/.profile "source -- $ALS_FULLPATH_SHELL/source/env.sh"

# als install upgrade
# any change in a package is considered an update, packages with an update.sh are to have update.sh run at every update and at install
# support multiple repos
# the following packages have been deleted from upstream, consider removing them

[ "$action" ] || exit 0

repos="$ALS_CUSTOM_FULLPATH/repository
$ALS_FULLPATH/repository"

IFS=$'\n' # TODO Support \n in filenames
set -f

package_fullpaths=
for repo in $repos; do
    [ -d "$repo" ] || continue
    package_fullpaths=$package_fullpaths$(find "$repo" -mindepth 1 -maxdepth 1)$'\n'
done

parse_packages() {
    packages=()
    for i in $package_fullpaths; do
        local package_name=$(basename -- "$i")
        local object_name=pkg_$package_name
        [ "${!object_name[name]+"${!object_name[name]}"}" ] && continue

        packages+=("$object_name")
        declare -A "$object_name"
        printf -v "${object_name}[name]" %s "$package_name"
        printf -v "${object_name}[fullpath]" %s "$package_name"
        printf -v "${object_name}[tags]" %s "$(cat -- "$i/tags.txt" 2> /dev/null || true)" # tags.txt contains \n-separated tags
        printf -v "${object_name}[installed]" %s "$([ -e "$ALS_INSTALLED_FULLPATH/packages/$package_name" ] && echo true || echo false)"
    done
}
parse_packages

print_package_array() {
    printf '%s\n' "$@"
}

print_all_packages() {
    print_package_array "${packages[@]}"
}

print_installed_packages() {
    local i pkgs=()
    for i in $(print_all_packages); do
        [ "${!i[installed]}" = true ] && pkgs+=("$i")
    done

    print_package_array "${pkgs[@]}"
}

print_packages_matching_tag() {
    local tag=$1 i pkgs=()
    for i in $(print_all_packages); do
        grep -Fx -- "$tag" <<< "${!i[tags]}" &> /dev/null && pkgs+=("$i") # TODO Do this in Bash
    done

    if [ "${pkgs[*]}" ]; then
        print_package_array "${pkgs[@]}"
    else
        print-err "No packages with tag '$tag' found"
    fi
}

