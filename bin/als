#!/bin/bash

source "$(dirname "$(dirname "$(realpath -- "$BASH_SOURCE")")")"/source/als-bin.sh || exit 1

# Bypass set -u
action=${1+"$1"}
shift || true

mkdir -p -- ~/bin ~/.local/bin ~/.local/share/applications ~/.config/autostart "$ALS_INSTALLED_FULLPATH" "$ALS_CUSTOM_FULLPATH" "$ALS_INSTALLED_FULLPATH"/{packages,programs,bin-symlinks} "$ALS_CUSTOM_FULLPATH"/{bin,autostart.d,env.d,repository}
ln -s -f -- "$ALS_FULLPATH"/source/ "$ALS_INSTALLED_FULLPATH"/source

cp -f -- "$ALS_FULLPATH"/als-autostart.desktop ~/.config/autostart/
put-line-in-file.sh ~/.bashrc "source $ALS_FULLPATH_SHELL/source/bashrc.sh"
put-line-in-file.sh ~/.profile "ALS_ARG_ALS_FULLPATH=$ALS_FULLPATH_SHELL source $ALS_FULLPATH_SHELL/source/profile.sh"

[ "$action" ] || exit 0

# Repositories before in the list have more priority for packages with the same name
pkg_repos=("$ALS_CUSTOM_FULLPATH/repository" "$ALS_FULLPATH/repository")

# Format to manipulate package names: arrays of package names
pkg_object_prefix=pkg_object_

fpkg_exists() {
    local package_name=$1
    local object_name=$pkg_object_prefix$package_name
    is_assoc_array "$object_name"
}

fpkg_field() {
    local package_name=$1 field=$2
    local object_name=$pkg_object_prefix$package_name
    printf '%s\n' "${!object_name[$field]}"
}

fpkg_set_field() {
    local package_name=$1 field=$2 value=$3
    local object_name=$pkg_object_prefix$package_name
    declare -A "$object_name"
    printf -v "${object_name}[$field]" %s "$value"
}

fpkg_parse_deps() {
    local path=$1
    [ -f "$path" ] || return 1
    printf '%s\n' $(sed -- 's/#.*//' "$path")
}

pkg_all=()
while IFS= read -rd '' i; do
    print-debug "Processing package '$i'"
    package_name=$(basename -- "$i")
    fpkg_exists "$package_name" && continue

    pkg_all+=("$package_name")
    fpkg_set_field "$package_name" name "$package_name"
    fpkg_set_field "$package_name" fullpath "$i"
    fpkg_set_field "$package_name" installed_fullpath "$ALS_INSTALLED_FULLPATH/packages/$package_name"
    fpkg_set_field "$package_name" tags "$(fpkg_parse_deps "$i/tags.txt" || true)"
done < <(find "${pkg_repos[@]}" -mindepth 1 -maxdepth 1 -print0)

print-debug "Point 1"

fpkg_is_installed() {
    local package_name=$1
    [ -e "$(f_pkg_field "$package_name" installed_fullpath)" ]
}

fpkg_get_all() {
    local var_name=$1 # The name of the variable in which we put the resulting array
    copy_array pkg_all "$var_name"
}

fpkg_get_installed() {
    local var_name=$1 i res=()
    for i in "${pkg_all[@]}"; do
        fpkg_is_installed "$i" && res+=("$i")
    done

    copy_array res "$var_name"
}

fpkg_get_matching_tag() {
    local var_name=$1 tag=$2 i res=()
    for i in "${pkg_all[@]}"; do
        grep -qFx -- "$tag" <<< "$(fpkg_field "$i" tags)" && res+=("$i") # TODO Do this in Bash?
    done

    copy_array res "$var_name"
}

fpkg_apt_update_once() {
    [ -v pkg_apt_update_once ] || {
        sudo apt update
        pkg_apt_update_once=true
    }
}

# We assume the package exists and is not installed
fpkg_install() {
    local package_name=$1
    local fullpath=$(f_pkg_field "$package_name" fullpath)

    local i
    for i in "$fullpath"/bin/*; do
        local basename=$(basename -- "$i")
        ln -s -f -- "../packages/$package_name/bin/$basename" "$ALS_INSTALLED_FULLPATH/bin-symlinks/$basename"
    done

    [ -d "$fullpath"/files-home ] && rsync -rl "$fullpath"/files-home/ ~/
    [ -d "$fullpath"/files-root ] && sudo rsync -rl "$fullpath"/files-root/ /


    [ -f "$fullpath/apt.txt" ] && {
        fpkg_apt_update_once
        sudo apt install -y $(fpkg_parse_deps "$fullpath/apt.txt")
    }

    [ -f "$fullpath/snap.txt" ] && sudo snap install $(fpkg_parse_deps "$fullpath/snap.txt")

    [ -f "$fullpath/snap-classic.txt" ] && sudo snap install --classic $(fpkg_parse_deps "$fullpath/snap-classic.txt")

    [ -f "$fullpath/pip.txt" ] && {
        type pip3 &> /dev/null || {
            fpkg_apt_update_once
            sudo apt install -y python3-pip
        }
        pip3 install $(fpkg_parse_deps "$fullpath/pip.txt")
    }

    [ -f "$fullpath/pipx.txt" ] && {
        type pipx &> /dev/null || {
            fpkg_apt_update_once
            sudo apt install -y pipx
        }
        pipx install $(fpkg_parse_deps "$fullpath/pipx.txt")
    }


    [ -f "$fullpath/stop-daemons.sh" ] && "$fullpath/stop-daemons.sh"
    [ -f "$fullpath/install.sh" ] && "$fullpath/install.sh"
    [ -f "$fullpath/autostart.sh" ] && "$fullpath/autostart.sh" & disown

    cp -r -- "$(f_pkg_field "$package_name" fullpath)" "$(f_pkg_field "$package_name" installed_fullpath)"
}

print-debug "Point 2"

# For now installing a package already installed does nothing
if [ "$action" = install ]; then
    to_install=()
    for i; do
        if [[ $i =~ ^'@'(.+) ]]; then
            fpkg_get_matching_tag to_append "${BASH_REMATCH[1]}"

            [ "${to_append[*]}" ] || {
                print-err "No packages with tag '${BASH_REMATCH[1]}' found"
                exit 1
            }

            to_install+=("${to_append[@]}")
        else
            fpkg_exists "$i" || {
                print-err "No package named '$i' found"
                exit 1
            }

            to_install+=("$i")
        fi
    done

    for i in "${to_install[@]}"; do
        { ! fpkg_is_installed "$i"; } && fpkg_install "$i"
    done
elif [ "$action" = list ]; then
    fpkg_get_all all_packages
    print-debug "All packages: ${all_packages[*]}"
    for i in "${all_packages[@]}"; do
        printf '%s ' "$i"
    done
    echo
elif [ "$action" = list-installed ]; then
    fpkg_get_installed installed_packages
    for i in "${installed_packages[@]}"; do
        printf '%s ' "$i"
    done
    echo
else
    print-err "Unknown action '$action'"
    exit 1
fi
