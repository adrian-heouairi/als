#!/bin/bash

# TODO I wrote this project before knowing about declare/local -n

source ~/.local/als/source/als-bin.sh || exit 1

# Bypass set -u
action=${1+"$1"}
shift || true

mkdir -p -- ~/bin ~/.local/bin ~/.local/share/applications ~/.config/autostart "$ALS_INSTALLED_FULLPATH" "$ALS_CUSTOM_FULLPATH" "$ALS_INSTALLED_FULLPATH"/{packages,programs,bin-symlinks} "$ALS_CUSTOM_FULLPATH"/{bin,autostart.d,env.d,repository}

echo "[Desktop Entry]
Exec=bash -c \"exec $ALS_FULLPATH_SHELL/bin/als-autostart.sh\"
Icon=dialog-scripts
Name=als-autostart.sh
Type=Application" > ~/.config/autostart/als-autostart.desktop

put-line-in-file.sh ~/.bashrc "source $ALS_FULLPATH_SHELL/source/bashrc.sh"
put-line-in-file.sh ~/.profile "source $ALS_FULLPATH_SHELL/source/profile.sh"

fpkg_apt_update_once() {
    [ -v pkg_apt_update_once ] || {
        sudo apt update
        pkg_apt_update_once=true
    }
}

if is-kde-neon.sh; then
    pkcon refresh
    pkcon update
else
    fpkg_apt_update_once
    sudo apt upgrade -y
fi
sudo snap refresh
cmd-exists.sh pip3 && pip3 install --upgrade
cmd-exists.sh pipx && pipx upgrade-all
cmd-exists.sh brew && brew upgrade

# Install basic dependencies
fpkg_apt_update_once
sudo apt install -y plocate rsync curl wget wmctrl xdotool x11-utils xsel git

# Repositories before in the list have more priority for packages with the same name
pkg_repos=("$ALS_CUSTOM_FULLPATH/repository" "$ALS_FULLPATH/repository")

# Format to manipulate package names: arrays of package names
pkg_object_prefix=pkg_object_

fpkg_exists() {
    local package_name=$1
    local object_name=$pkg_object_prefix$package_name
    is_assoc_array "$object_name"
}

fpkg_field() {
    local package_name=$1 field=$2
    local object_name_field=$pkg_object_prefix$package_name"[$field]"
    printf '%s\n' "${!object_name_field}"
}

fpkg_set_field() {
    local package_name=$1 field=$2 value=$3
    local object_name=$pkg_object_prefix$package_name
    declare -A -g "$object_name"
    printf -v "${object_name}[$field]" %s "$value"
}

fpkg_parse_deps() {
    local path=$1
    [ -f "$path" ] || return 1
    printf '%s\n' $(sed -- 's/#.*//' "$path")
}

pkg_all=()
while IFS= read -rd '' i; do
    package_name=$(basename -- "$i")
    fpkg_exists "$package_name" && continue

    pkg_all+=("$package_name")
    fpkg_set_field "$package_name" name "$package_name"
    fpkg_set_field "$package_name" fullpath "$i"
    fpkg_set_field "$package_name" installed_fullpath "$ALS_INSTALLED_FULLPATH/packages/$package_name"
    fpkg_set_field "$package_name" tags "$(fpkg_parse_deps "$i/tags.txt" || true)"
done < <(find "${pkg_repos[@]}" -mindepth 1 -maxdepth 1 -print0)


fpkg_is_installed() {
    local package_name=$1
    [ -e "$(fpkg_field "$package_name" installed_fullpath)" ]
}

fpkg_get_all() {
    local var_name=$1 # The name of the variable in which we put the resulting array
    copy_array pkg_all "$var_name"
}

fpkg_get_installed() {
    local var_name=$1 i res=()
    for i in "${pkg_all[@]}"; do
        fpkg_is_installed "$i" && res+=("$i")
    done

    copy_array res "$var_name"
}

fpkg_get_matching_tag() {
    local var_name=$1 tag=$2 res=() # tag is without '@' prefix

    if [ "$tag" = all ]; then
        fpkg_get_all "$var_name"
        remove_val_from_array_no_hole "$var_name" test
    else
        local i
        for i in "${pkg_all[@]}"; do
            grep -qFx -- "$tag" <<< "$(fpkg_field "$i" tags)" && res+=("$i") # TODO Do this in Bash?
        done
        copy_array res "$var_name"
    fi
}

# Set $2 to upgrade instead of install
fpkg_install() {
    local package_name=$1

    fpkg_exists "$package_name" || print_err_exit "No package named '$package_name' found"

    local fullpath=$(fpkg_field "$package_name" fullpath)
    local i

    for i in $(fpkg_parse_deps "$fullpath/deps.txt"); do
        fpkg_is_installed "$i" || {
            print_info "Installing dependency '$i' for package '$package_name'"
            fpkg_install "$i"
        }
    done

    for i in "$fullpath"/bin/*; do
        local basename=$(basename -- "$i")
        ln -s -f -- "../packages/$package_name/bin/$basename" "$ALS_INSTALLED_FULLPATH/bin-symlinks/$basename"
    done

    [ -d "$fullpath"/files-home ] && rsync -rl "$fullpath"/files-home/ ~/
    [ -d "$fullpath"/files-root ] && sudo rsync -rl "$fullpath"/files-root/ /


    [ -f "$fullpath/apt.txt" ] && {
        while pgrep -a '^(apt|dpkg)' || pidof -x unattended-upgrades; do
            print_info "Waiting for apt/dpkg/unattended-upgrades to end"
            sleep 1
        done

        fpkg_apt_update_once
        sudo apt install -y $(fpkg_parse_deps "$fullpath/apt.txt")
    }

    [ -f "$fullpath/snap.txt" ] && sudo snap install $(fpkg_parse_deps "$fullpath/snap.txt")

    [ -f "$fullpath/snap-classic.txt" ] && sudo snap install --classic $(fpkg_parse_deps "$fullpath/snap-classic.txt")

    [ -f "$fullpath/pip.txt" ] && {
        type pip3 &> /dev/null || {
            fpkg_apt_update_once
            sudo apt install -y python3-pip
        }
        pip3 install --user --break-system-packages $(fpkg_parse_deps "$fullpath/pip.txt")
    }

    [ -f "$fullpath/pipx.txt" ] && {
        type pipx &> /dev/null || {
            fpkg_apt_update_once
            sudo apt install -y pipx
        }
        pipx install $(fpkg_parse_deps "$fullpath/pipx.txt")
    }

    [ -f "$fullpath/brew.txt" ] && {
        type brew &> /dev/null || {
            fpkg_apt_update_once
            sudo apt install -y build-essential procps curl file git
            /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            (echo; echo 'eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"') >> ~/.bashrc
            eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
        }
        ulimit -Sn "$(ulimit -Hn)"
        brew install $(fpkg_parse_deps "$fullpath/brew.txt")
    }


    [ -f "$fullpath/stop-daemons.sh" ] && "$fullpath/stop-daemons.sh"
    if (($# > 1)); then
        [ -f "$fullpath/upgrade.sh" ] && "$fullpath/upgrade.sh"
    else
        [ -f "$fullpath/install.sh" ] && "$fullpath/install.sh"
    fi
    [ -f "$fullpath/autostart.sh" ] && "$fullpath/autostart.sh" & disown

    cp -r -- "$(fpkg_field "$package_name" fullpath)" "$(fpkg_field "$package_name" installed_fullpath)"
}

# Assumes the package is installed
fpkg_remove() {
    local package_name=$1
    local installed_fullpath=$(fpkg_field "$package_name" installed_fullpath)

    [ -f "$installed_fullpath/stop-daemons.sh" ] && "$installed_fullpath/stop-daemons.sh"

    rm -rf -- "$installed_fullpath"
}

# Assumes the package is installed
fpkg_upgrade() {
    local package_name=$1

    if diff -rq -- "$(fpkg_field "$package_name" fullpath)" "$(fpkg_field "$package_name" installed_fullpath)" &> /dev/null && [ ! -e "$(fpkg_field "$package_name" fullpath)"/upgrade.sh ]; then
        print_info "Package '$package_name' is already up to date, skipping"
    else
        fpkg_remove "$package_name"
        fpkg_install "$package_name" upgrade
    fi
}

fpkg_print_array() {
    if (($# > 0)); then
        printf '%s\n' "$*"
    else
        true
    fi
}

# TODO Handle multiple times the same package
fpkg_parse_args() {
    local var_name=$1 res=()
    shift

    for i; do
            if [[ $i =~ ^'@'(.+) ]]; then
                fpkg_get_matching_tag pkg_to_append "${BASH_REMATCH[1]}"

                [ "${pkg_to_append[*]}" ] || print_err_exit "No packages with tag '${BASH_REMATCH[1]}' found"

                res+=("${pkg_to_append[@]}")
            else
                fpkg_exists "$i" || print_err_exit "No package named '$i' found"

                res+=("$i")
            fi
        done

        copy_array res "$var_name"
}

if [ "$action" = install ]; then
    (($# == 0)) && print_err_exit "No arguments given"

    fpkg_parse_args to_install "$@"

    for i in "${to_install[@]}"; do
        fpkg_is_installed "$i" && print_err_exit "'$i' is already installed"
    done

    for i in "${to_install[@]}"; do
        fpkg_install "$i"
    done
elif [ "$action" = upgrade ]; then
    if (($# == 0)); then
        fpkg_get_installed to_upgrade
    else
        fpkg_parse_args to_upgrade "$@"
    fi

    for i in "${to_upgrade[@]}"; do
        fpkg_is_installed "$i" || print_err_exit "'$i' is not installed"
    done

    for i in "${to_upgrade[@]}"; do
        fpkg_upgrade "$i"
    done
elif [ "$action" = remove ]; then
    (($# == 0)) && print_err_exit "No arguments given"

    fpkg_parse_args to_remove "$@"

    for i in "${to_remove[@]}"; do
        fpkg_is_installed "$i" || print_err_exit "'$i' is not installed"
    done

    for i in "${to_remove[@]}"; do
        fpkg_remove "$i"
    done
elif [ "$action" = list ]; then
    fpkg_get_all all_packages
    fpkg_print_array "${all_packages[@]}"
elif [ "$action" = list-installed ]; then
    fpkg_get_installed installed_packages
    fpkg_print_array "${installed_packages[@]}"
fi

# Delete broken symlinks
find "$ALS_INSTALLED_FULLPATH"/bin-symlinks -xtype l -delete
