#!/bin/bash

source "$(dirname "$(dirname "$(realpath -- "$BASH_SOURCE")")")"/source/als-bin.sh || exit 1

# Bypass set -u
action=${1+"$1"}
shift || true

mkdir -p -- ~/bin ~/.local/bin ~/.local/share/applications ~/.config/autostart "$ALS_INSTALLED_FULLPATH" "$ALS_CUSTOM_FULLPATH" "$ALS_INSTALLED_FULLPATH"/{packages,programs,bin-symlinks} "$ALS_CUSTOM_FULLPATH"/{bin,autostart.d,env.d,repository}
ln -s -f -- "$ALS_FULLPATH"/source/ "$ALS_INSTALLED_FULLPATH"/source

cp -f -- "$ALS_FULLPATH"/als-autostart.desktop ~/.config/autostart/
put-line-in-file.sh ~/.bashrc "source $ALS_FULLPATH_SHELL/source/bashrc.sh"
put-line-in-file.sh ~/.profile "ALS_ARG_ALS_FULLPATH=$ALS_FULLPATH_SHELL source $ALS_FULLPATH_SHELL/source/profile.sh"

[ "$action" ] || exit 0

# Repositories before in the list have more priority for packages with the same name
pkg_repos=("$ALS_CUSTOM_FULLPATH/repository" "$ALS_FULLPATH/repository")

# Format to manipulate package names: arrays of package names
pkg_object_prefix=pkg_object_

fpkg_exists() {
    local package_name=$1
    local object_name=$pkg_object_prefix$package_name
    is_assoc_array "$object_name"
}

fpkg_field() {
    local package_name=$1 field=$2
    local object_name_field=$pkg_object_prefix$package_name"[$field]"
    printf '%s\n' "${!object_name_field}"
}

fpkg_set_field() {
    local package_name=$1 field=$2 value=$3
    local object_name=$pkg_object_prefix$package_name
    declare -A -g "$object_name"
    printf -v "${object_name}[$field]" %s "$value"
}

fpkg_parse_deps() {
    local path=$1
    [ -f "$path" ] || return 1
    printf '%s\n' $(sed -- 's/#.*//' "$path")
}

pkg_all=()
while IFS= read -rd '' i; do
    package_name=$(basename -- "$i")
    fpkg_exists "$package_name" && continue

    pkg_all+=("$package_name")
    fpkg_set_field "$package_name" name "$package_name"
    fpkg_set_field "$package_name" fullpath "$i"
    fpkg_set_field "$package_name" installed_fullpath "$ALS_INSTALLED_FULLPATH/packages/$package_name"
    fpkg_set_field "$package_name" tags "$(fpkg_parse_deps "$i/tags.txt" || true)"
done < <(find "${pkg_repos[@]}" -mindepth 1 -maxdepth 1 -print0)


fpkg_is_installed() {
    local package_name=$1
    [ -e "$(fpkg_field "$package_name" installed_fullpath)" ]
}

fpkg_get_all() {
    local var_name=$1 # The name of the variable in which we put the resulting array
    copy_array pkg_all "$var_name"
}

fpkg_get_installed() {
    local var_name=$1 i res=()
    for i in "${pkg_all[@]}"; do
        fpkg_is_installed "$i" && res+=("$i")
    done

    copy_array res "$var_name"
}

fpkg_get_matching_tag() {
    local var_name=$1 tag=$2 i res=()
    for i in "${pkg_all[@]}"; do
        grep -qFx -- "$tag" <<< "$(fpkg_field "$i" tags)" && res+=("$i") # TODO Do this in Bash?
    done

    copy_array res "$var_name"
}

fpkg_apt_update_once() {
    [ -v pkg_apt_update_once ] || {
        sudo apt update
        pkg_apt_update_once=true
    }
}

# We assume the package exists and is not installed
fpkg_install() {
    local package_name=$1
    local fullpath=$(fpkg_field "$package_name" fullpath)

    local i
    for i in "$fullpath"/bin/*; do
        local basename=$(basename -- "$i")
        ln -s -f -- "../packages/$package_name/bin/$basename" "$ALS_INSTALLED_FULLPATH/bin-symlinks/$basename"
    done

    [ -d "$fullpath"/files-home ] && rsync -rl "$fullpath"/files-home/ ~/
    [ -d "$fullpath"/files-root ] && sudo rsync -rl "$fullpath"/files-root/ /


    [ -f "$fullpath/apt.txt" ] && {
        fpkg_apt_update_once
        sudo apt install -y $(fpkg_parse_deps "$fullpath/apt.txt")
    }

    [ -f "$fullpath/snap.txt" ] && sudo snap install $(fpkg_parse_deps "$fullpath/snap.txt")

    [ -f "$fullpath/snap-classic.txt" ] && sudo snap install --classic $(fpkg_parse_deps "$fullpath/snap-classic.txt")

    [ -f "$fullpath/pip.txt" ] && {
        type pip3 &> /dev/null || {
            fpkg_apt_update_once
            sudo apt install -y python3-pip
        }
        pip3 install --user --break-system-packages $(fpkg_parse_deps "$fullpath/pip.txt")
    }

    [ -f "$fullpath/pipx.txt" ] && {
        type pipx &> /dev/null || {
            fpkg_apt_update_once
            sudo apt install -y pipx
        }
        pipx install $(fpkg_parse_deps "$fullpath/pipx.txt")
    }


    [ -f "$fullpath/stop-daemons.sh" ] && "$fullpath/stop-daemons.sh"
    [ -f "$fullpath/install.sh" ] && "$fullpath/install.sh"
    [ -f "$fullpath/autostart.sh" ] && "$fullpath/autostart.sh" & disown

    cp -r -- "$(fpkg_field "$package_name" fullpath)" "$(fpkg_field "$package_name" installed_fullpath)"
}

# Assumes the package is installed
fpkg_remove() {
    local package_name=$1
    local installed_fullpath=$(fpkg_field "$package_name" installed_fullpath)

    [ -f "$installed_fullpath/stop-daemons.sh" ] && "$installed_fullpath/stop-daemons.sh"

    rm -rf -- "$installed_fullpath"
}

# Assumes the package is installed
fpkg_upgrade() {
    local package_name=$1

    fpkg_remove "$package_name"
    fpkg_install "$package_name"
}

fpkg_print_array() {
    (($# > 0)) && printf '%s\n' "$*" || true
}

fpkg_parse_args() {
    local var_name=$1 res=()
    shift

    for i; do
            if [[ $i =~ ^'@'(.+) ]]; then
                fpkg_get_matching_tag pkg_to_append "${BASH_REMATCH[1]}"

                [ "${pkg_to_append[*]}" ] || print_err_exit "No packages with tag '${BASH_REMATCH[1]}' found"

                res+=("${pkg_to_append[@]}")
            else
                fpkg_exists "$i" || print_err_exit "No package named '$i' found"

                res+=("$i")
            fi
        done

        copy_array res "$var_name"
}

if [ "$action" = install ]; then
    fpkg_parse_args to_install "$@"

    for i in "${to_install[@]}"; do
        fpkg_is_installed "$i" && print_err_exit "'$i' is already installed"
    done

    for i in "${to_install[@]}"; do
        fpkg_install "$i"
    done
elif [ "$action" = upgrade ]; then
    fpkg_parse_args to_upgrade "$@"

    for i in "${to_upgrade[@]}"; do
        fpkg_is_installed "$i" || print_err_exit "'$i' is not installed"
    done

    for i in "${to_upgrade[@]}"; do
        fpkg_upgrade "$i"
    done
elif [ "$action" = remove ]; then
    fpkg_parse_args to_remove "$@"

    for i in "${to_remove[@]}"; do
        fpkg_is_installed "$i" || print_err_exit "'$i' is not installed"
    done

    for i in "${to_remove[@]}"; do
        fpkg_remove "$i"
    done
elif [ "$action" = list ]; then
    fpkg_get_all all_packages
    fpkg_print_array "${all_packages[@]}"
elif [ "$action" = list-installed ]; then
    fpkg_get_installed installed_packages
    fpkg_print_array "${installed_packages[@]}"
else
    print_err_exit "Unknown action '$action'"
fi
